// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.8.0
// - protoc             v5.27.2
// source: user.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationUserServiceDeleteUser = "/helloworld.v1.UserService/DeleteUser"
const OperationUserServiceGetAllUser = "/helloworld.v1.UserService/GetAllUser"
const OperationUserServiceRefreshAccessToken = "/helloworld.v1.UserService/RefreshAccessToken"
const OperationUserServiceSignInUser = "/helloworld.v1.UserService/SignInUser"
const OperationUserServiceSignUpUser = "/helloworld.v1.UserService/SignUpUser"

type UserServiceHTTPServer interface {
	DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserRespone, error)
	GetAllUser(context.Context, *GetAllUserRequest) (*GetAllUserRespone, error)
	RefreshAccessToken(context.Context, *RefreshAccessTokenRequest) (*RefreshAccessTokenRespone, error)
	SignInUser(context.Context, *SignInUserRequest) (*SignInUserRespone, error)
	SignUpUser(context.Context, *SignUpUserRequest) (*SignUpUserRespone, error)
}

func RegisterUserServiceHTTPServer(s *http.Server, srv UserServiceHTTPServer) {
	r := s.Route("/")
	r.POST("/users", _UserService_SignUpUser0_HTTP_Handler(srv))
	r.POST("/users/signin", _UserService_SignInUser0_HTTP_Handler(srv))
	r.GET("/users", _UserService_GetAllUser0_HTTP_Handler(srv))
	r.DELETE("/users/{id}", _UserService_DeleteUser0_HTTP_Handler(srv))
	r.POST("/users/refresh_access_token", _UserService_RefreshAccessToken0_HTTP_Handler(srv))
}

func _UserService_SignUpUser0_HTTP_Handler(srv UserServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SignUpUserRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationUserServiceSignUpUser)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SignUpUser(ctx, req.(*SignUpUserRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SignUpUserRespone)
		return ctx.Result(200, reply)
	}
}

func _UserService_SignInUser0_HTTP_Handler(srv UserServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SignInUserRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationUserServiceSignInUser)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SignInUser(ctx, req.(*SignInUserRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SignInUserRespone)
		return ctx.Result(200, reply)
	}
}

func _UserService_GetAllUser0_HTTP_Handler(srv UserServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetAllUserRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationUserServiceGetAllUser)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetAllUser(ctx, req.(*GetAllUserRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetAllUserRespone)
		return ctx.Result(200, reply)
	}
}

func _UserService_DeleteUser0_HTTP_Handler(srv UserServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteUserRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationUserServiceDeleteUser)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteUser(ctx, req.(*DeleteUserRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteUserRespone)
		return ctx.Result(200, reply)
	}
}

func _UserService_RefreshAccessToken0_HTTP_Handler(srv UserServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RefreshAccessTokenRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationUserServiceRefreshAccessToken)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RefreshAccessToken(ctx, req.(*RefreshAccessTokenRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*RefreshAccessTokenRespone)
		return ctx.Result(200, reply)
	}
}

type UserServiceHTTPClient interface {
	DeleteUser(ctx context.Context, req *DeleteUserRequest, opts ...http.CallOption) (rsp *DeleteUserRespone, err error)
	GetAllUser(ctx context.Context, req *GetAllUserRequest, opts ...http.CallOption) (rsp *GetAllUserRespone, err error)
	RefreshAccessToken(ctx context.Context, req *RefreshAccessTokenRequest, opts ...http.CallOption) (rsp *RefreshAccessTokenRespone, err error)
	SignInUser(ctx context.Context, req *SignInUserRequest, opts ...http.CallOption) (rsp *SignInUserRespone, err error)
	SignUpUser(ctx context.Context, req *SignUpUserRequest, opts ...http.CallOption) (rsp *SignUpUserRespone, err error)
}

type UserServiceHTTPClientImpl struct {
	cc *http.Client
}

func NewUserServiceHTTPClient(client *http.Client) UserServiceHTTPClient {
	return &UserServiceHTTPClientImpl{client}
}

func (c *UserServiceHTTPClientImpl) DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...http.CallOption) (*DeleteUserRespone, error) {
	var out DeleteUserRespone
	pattern := "/users/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationUserServiceDeleteUser))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *UserServiceHTTPClientImpl) GetAllUser(ctx context.Context, in *GetAllUserRequest, opts ...http.CallOption) (*GetAllUserRespone, error) {
	var out GetAllUserRespone
	pattern := "/users"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationUserServiceGetAllUser))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *UserServiceHTTPClientImpl) RefreshAccessToken(ctx context.Context, in *RefreshAccessTokenRequest, opts ...http.CallOption) (*RefreshAccessTokenRespone, error) {
	var out RefreshAccessTokenRespone
	pattern := "/users/refresh_access_token"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationUserServiceRefreshAccessToken))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *UserServiceHTTPClientImpl) SignInUser(ctx context.Context, in *SignInUserRequest, opts ...http.CallOption) (*SignInUserRespone, error) {
	var out SignInUserRespone
	pattern := "/users/signin"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationUserServiceSignInUser))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *UserServiceHTTPClientImpl) SignUpUser(ctx context.Context, in *SignUpUserRequest, opts ...http.CallOption) (*SignUpUserRespone, error) {
	var out SignUpUserRespone
	pattern := "/users"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationUserServiceSignUpUser))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
